// TELEGRAM_TOKEN рдФрд░ TELEGRAM_API_URL рдХреЛ рдХреЗрд╡рд▓ рдПрдХ рдмрд╛рд░ рдбрд┐рдХреНрд▓реЗрдпрд░ рдХрд░реЗрдВ
const TELEGRAM_TOKEN = "your_bot_token"; // рдЕрдкрдиреЗ рдмреЙрдЯ рдХрд╛ рдЯреЛрдХрди рдпрд╣рд╛рдВ рдбрд╛рд▓реЗрдВ
const TELEGRAM_API_URL = `https://api.telegram.org/bot${TELEGRAM_TOKEN}`; // API URL

// Webhook рд╕реЗрдЯ рдХрд░рдиреЗ рдХрд╛ рдлрдВрдХреНрд╢рди
function setWebhook() {
  const webhookUrl = "https://script.google.com/macros/s/AKfycbxIUWVK7n8njqd4fsgyq7JzBBKfzTjfQcWydDvtBS9pe02hQluGHYnFF2q2j98z0VgH/exec"; // рдЕрдкрдирд╛ Web App URL рдпрд╣рд╛рдВ рдбрд╛рд▓реЗрдВ
  const url = `${TELEGRAM_API_URL}/setWebhook?url=${webhookUrl}`;

  try {
    const response = UrlFetchApp.fetch(url);
    Logger.log(response.getContentText()); // Response рдХреЛ рд▓реЙрдЧ рдХрд░реЗрдВ
  } catch (error) {
    Logger.log("Error setting webhook: " + error.message); // Error рдХреЛ рд▓реЙрдЧ рдХрд░реЗрдВ
  }
}

// Webhook рдЪреЗрдХ рдХрд░рдиреЗ рдХрд╛ рдлрдВрдХреНрд╢рди
function checkWebhook() {
  const url = `${TELEGRAM_API_URL}/getWebhookInfo`;
  try {
    const response = UrlFetchApp.fetch(url);
    Logger.log("Webhook info: " + response.getContentText());
  } catch (error) {
    Logger.log("Error checking webhook: " + error.message);
  }
}

// India Post API рд╕реЗ рд▓реЛрдХреЗрд╢рди рдбрд┐рдЯреЗрд▓реНрд╕ рдкреНрд░рд╛рдкреНрдд рдХрд░рдиреЗ рдХрд╛ рдлрдВрдХреНрд╢рди
function getLocationByPin(pinCode) {
  const url = `https://api.postalpincode.in/pincode/${pinCode}`;
  try {
    const response = UrlFetchApp.fetch(url);
    const data = JSON.parse(response.getContentText());
    if (data[0].Status === "Success" && data[0].PostOffice && data[0].PostOffice.length > 0) {
      const postOffice = data[0].PostOffice[0];
      return {
        district: postOffice.District.toLowerCase(),
        state: postOffice.State.toLowerCase()
      };
    }
    return null; // рдЕрдЧрд░ рдбреЗрдЯрд╛ рдЙрдкрд▓рдмреНрдз рдирд╣реАрдВ рд╣реИ
  } catch (error) {
    Logger.log("Error fetching location: " + error.message);
    return null;
  }
}

// Fuzzy Matching рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░рдиреЗ рд╡рд╛рд▓рд╛ рдлрдВрдХреНрд╢рди
function fuzzyMatch(str1, str2) {
  str1 = str1.toLowerCase();
  str2 = str2.toLowerCase();
  let matches = 0;
  for (let char of str1) {
    if (str2.includes(char)) matches++;
  }
  const similarity = (matches / Math.max(str1.length, str2.length)) * 100;
  return similarity >= 60; // 60% рдпрд╛ рдЙрд╕рд╕реЗ рдЕрдзрд┐рдХ рд╕рдорд╛рдирддрд╛ рдХреЗ рд▓рд┐рдП True рд▓реМрдЯрд╛рдПрдВ
}

// Message рдкреНрд░реЛрд╕реЗрд╕ рдХрд░рдиреЗ рдХрд╛ рдлрдВрдХреНрд╢рди
function doPost(e) {
  try {
    const data = JSON.parse(e.postData.contents);
    Logger.log("Received data: " + JSON.stringify(data));

    const chatId = data.message.chat.id;
    const text = data.message.text;

    // /start рдХрдорд╛рдВрдб рдХреА рдЪреЗрдХрд┐рдВрдЧ
    if (text.toLowerCase() === "/start") {
      sendMessage(chatId, "Welcome to the order bot! Please provide your order details in the following format:\nName: your name\nAddress: your address\nPincode: your pincode\nDistrict: your district\nState: your state\nPhone Number: your phone number\nOrder Details: your order");
      return;
    }

    // рдСрд░реНрдбрд░ рдбрд┐рдЯреЗрд▓реНрд╕ рдкрд╛рд░реНрд╕ рдХрд░реЗрдВ
    const orderDetails = parseOrderData(text);
    // **Console me parsed data print karna**
    Logger.log("Parsed Order Details: " + JSON.stringify(orderDetails));

    // District fallback logic
    const districtGroupMap = {
      'bhind': '-1002413173548',
      'morena': '-1002270975638',
      'gwalior': '-1002420457309',
      'shivpuri': '-1009876543210',
      // рдЕрдиреНрдп рдЬрд┐рд▓реЛрдВ рдХреЗ рд▓рд┐рдП рдЬреЛрдбрд╝реЗрдВ
    };

    let matchedDistrict = null;

    // API рд╕реЗ рд▓реЛрдХреЗрд╢рди рдкреНрд░рд╛рдкреНрдд рдХрд░реЗрдВ
    const apiLocation = getLocationByPin(orderDetails.pincode);

    if (apiLocation) {
      // API рд╕реЗ fuzzy match рдХрд╛ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВ
      const fuzzyMatchResult = fuzzyMatch(orderDetails.district, apiLocation.district);

      if (fuzzyMatchResult) {
        orderDetails.district = apiLocation.district;
        orderDetails.state = apiLocation.state;
      } else {
        sendMessage(chatId, "API рд╕реЗ рдорд┐рд▓рд╛ рдЬрд┐рд▓рд╛ рдЖрдкрдХреЗ рджреНрд╡рд╛рд░рд╛ рджрд┐рдП рдЧрдП рдЬрд┐рд▓реЗ рд╕реЗ рдореЗрд▓ рдирд╣реАрдВ рдЦрд╛рддрд╛ред District mapping рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░ рд░рд╣реЗ рд╣реИрдВ...");
      }
    } else {
      sendMessage(chatId, "API рд╕реЗ рд▓реЛрдХреЗрд╢рди рдбреЗрдЯрд╛ рдирд╣реАрдВ рдорд┐рд▓ рд╕рдХрд╛ред District mapping рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░ рд░рд╣реЗ рд╣реИрдВ...");
    }

    // Fallback: рдЕрдЧрд░ API fuzzy match рдирд╣реАрдВ рдХрд░ рдкрд╛рдИ рдпрд╛ API рд╕реЗ рдбреЗрдЯрд╛ рдирд╣реАрдВ рдорд┐рд▓рд╛ рддреЛ districtGroupMap рд╕реЗ fuzzy match рдХрд░реЗрдВ
    if (!apiLocation || !fuzzyMatch(orderDetails.district, apiLocation.district)) {
      for (const district in districtGroupMap) {
        if (fuzzyMatch(orderDetails.district, district)) {
          matchedDistrict = district;
          orderDetails.district = matchedDistrict; // Match рд╣реБрдЖ рдЬрд┐рд▓рд╛ рдЕрдкрдбреЗрдЯ рдХрд░реЗрдВ
          break;
        }
      }

      if (!matchedDistrict) {
        sendMessage(chatId, "рдЖрдкрдХреЗ рджреНрд╡рд╛рд░рд╛ рджрд┐рдпрд╛ рдЧрдпрд╛ рдЬрд┐рд▓рд╛ рд╣рдорд╛рд░реЗ рд╕рд┐рд╕реНрдЯрдо рдореЗрдВ рдирд╣реАрдВ рдкрд╛рдпрд╛ рдЧрдпрд╛ред рдХреГрдкрдпрд╛ рдкреБрдирдГ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВред");
        return;
      }
    }

    // Order рдХреЛ Google Sheet рдореЗрдВ рд╕реЗрд╡ рдХрд░реЗрдВ
    saveOrderToSheet(orderDetails);

    // Order рдХреЛ рд╕рдВрдмрдВрдзрд┐рдд District Group рдореЗрдВ рднреЗрдЬреЗрдВ
    sendOrderToDistrictGroup(orderDetails, chatId);
    sendMessage(chatId, "рдСрд░реНрдбрд░ рдкреНрд░рд╛рдкреНрдд рд╣реБрдЖ рдФрд░ рд╕рдВрдмрдВрдзрд┐рдд рд╕рдореВрд╣ рдореЗрдВ рднреЗрдЬ рджрд┐рдпрд╛ рдЧрдпрд╛!\nOrder received and sent to the relevant group.");

  } catch (error) {
    Logger.log("Error in doPost: " + error.message);
    sendMessage(data.message.chat.id, "Sorry, an error occurred while processing your order.");
  }
}

// Order рдХреЛ Google Sheets рдореЗрдВ рд╕реЗрд╡ рдХрд░реЗрдВ
function saveOrderToSheet(orderDetails) {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();

  if (sheet.getLastRow() === 0) {
    sheet.appendRow(['Name', 'Address', 'Pincode', 'District', 'State', 'Phone Number', 'Order Details']);
  }

  sheet.appendRow([ 
    orderDetails.name,
    orderDetails.address,
    orderDetails.pincode,
    orderDetails.district,
    orderDetails.state,
    orderDetails.phone,
    orderDetails.orderDetails
  ]);
}

// Order рдХреЛ рд╕рдВрдмрдВрдзрд┐рдд District Group рдореЗрдВ рднреЗрдЬреЗрдВ
function sendOrderToDistrictGroup(orderDetails, chatId) {
  const districtGroupMap = {
    'bhind': '-1002413173548',
    'morena': '-1002270975638',
    'gwalior': '-1002420457309',
    'shivpuri': '-1009876543210',
    // рдЕрдиреНрдп рдЬрд┐рд▓реЛрдВ рдХреЗ рд▓рд┐рдП рдЬреЛрдбрд╝реЗрдВ
  };

  const groupChatId = districtGroupMap[orderDetails.district.toLowerCase()];
  if (!groupChatId) {
    sendMessage(chatId, "Sorry, we don't have a group for your district yet.");
    return;
  }

  const message = `New Order:\nЁЯСдName: ${orderDetails.name}\nЁЯУНAddress: ${orderDetails.address}\nЁЯУМPincode: ${orderDetails.pincode}\nЁЯПЩDistrict: ${orderDetails.district}\nЁЯПЫState: ${orderDetails.state}\nЁЯУЮPhone: ${orderDetails.phone}\nЁЯУЭOrder: ${orderDetails.orderDetails}`;
  sendMessage(groupChatId, message);
}

// Message рднреЗрдЬрдиреЗ рдХрд╛ рдлрдВрдХреНрд╢рди
function sendMessage(chatId, text) {
  const url = `${TELEGRAM_API_URL}/sendMessage`;
  const payload = {
    chat_id: chatId,
    text: text
  };
  const options = {
    method: "post",
    contentType: "application/json",
    payload: JSON.stringify(payload)
  };

  try {
    const response = UrlFetchApp.fetch(url, options);
    Logger.log("Message sent: " + response.getContentText());
  } catch (error) {
    Logger.log("Error sending message: " + error.message);
  }
}

// Field mapping ke liye synonyms
const FIELD_SYNONYMS = {
  /* name: ["naam","name", "nam", "mera naam", "mere naam","рдореЗрд░рд╛ рдирд╛рдо", "рдореЗрд░реЗ рдирд╛рдо", "рдирд╛рдо", "рдореЗрд░рд╛ рд╢реБрдн рдирд╛рдо", "рд╢реБрднрдирд╛рдо", 
    "my name", "my name is", "рдирд╛рдо рдХреНрдпрд╛ рд╣реИ", "рдЕрдкрдирд╛ рдирд╛рдо"], // Name ke keywords */

   address: ["address","my address", "adress","my address is", "add", "рдкрддрд╛", "рдореЗрд░рд╛ рдкрддрд╛","рдкреВрд░рд╛ рдкрддрд╛", "рдлреБрд▓ рдПрдбреНрд░реЗрд╕", "full address", "poora pta", 
    "рдШрд░ рдХрд╛ рдкрддрд╛", "address detail","pata", "рдкрддрд╛ рд▓рд┐рдЦреЗрдВ"], // Address ke keywords

  pincode: ["pincode", "pin code", "pin","post code", "postal code", "postcode", "zip","рдкрд┐рди", "рдкрд┐рдирдХреЛрдб", "zip code", "рдбрд╛рдХ рдХреЛрдб", "рдкреЛрд╕реНрдЯ рдХреЛрдб"], // Pincode ke keywords

  district: ["my district name is", "district","my district is", "district is", "mera jila", "jila", "dist", "zilla", "рдЬрд┐рд▓рд╛", "рдЬрд╝рд┐рд▓рд╛","рдбрд┐рд╕реНрдЯреНрд░рд┐рдХреНрдЯ", "рдбрд┐рд╕реНрдЯреНрд░рд┐рдХ", "zila", "mera zilla hai"], // District ke keywords

  state: ["state", "rajya", "state name", "рд░рд╛рдЬреНрдп","рд╕реНрдЯреЗрдЯ", "рд╕реНрдЯреЗрдЯ рдиреЗрдо"], // State ke keywords

  phone: ["phone number", "phone", "mobile", "mob","mob no","ph no", "mobile number","contact", "contact number", "рдлреЛрди рдирдВрдмрд░", "рдореЛрдмрд╛рдЗрд▓","рдореЛрдмрд╛рдЗрд▓ рдирдВрдмрд░", "рд╕рдВрдкрд░реНрдХ", "рд╕рдВрдкрд░реНрдХ рдирдВрдмрд░", "рдореЛрдмрд╛рдЗрд▓ рдлреЛрди"], // Phone number ke keywords

  orderDetails: ["order details", "order", "details", "рдЖрджреЗрд╢","рдЖрджреЗрд╢ рд╡рд┐рд╡рд░рдг", "рдСрд░реНрдбрд░", "рдСрд░реНрдбрд░ рдбрд┐рдЯреЗрд▓реНрд╕", "рд╡рд┐рд╡рд░рдг","рдСрд░реНрдбрд░ рдХреНрдпрд╛ рд╣реИ", "рдСрд░реНрдбрд░ рдЬрд╛рдирдХрд╛рд░реА", "order info","order information"], // Order Details ke keywords

  name: ["naam","name", "nam", "mera naam", "mere naam","рдореЗрд░рд╛ рдирд╛рдо", "рдореЗрд░реЗ рдирд╛рдо", "рдирд╛рдо", "рдореЗрд░рд╛ рд╢реБрдн рдирд╛рдо", "рд╢реБрднрдирд╛рдо", 
    "my name", "my name is", "рдирд╛рдо рдХреНрдпрд╛ рд╣реИ", "рдЕрдкрдирд╛ рдирд╛рдо"], // Name ke keywords 

  pgaaaali: ["lopaaadff", "ladaaaiss"]

};

const regexCache = {};

// Function to create regex pattern for each field with boundaries
function createFieldRegex(fieldName, allFields) {
  if (!regexCache[fieldName]) {
    // Sort synonyms by length (longest first)
    const synonyms = FIELD_SYNONYMS[fieldName].sort((a, b) => b.length - a.length);

    // Create boundary pattern for all fields (excluding the current field)
    const boundaryFields = allFields.filter(f => f !== fieldName);
    const boundaryPattern = boundaryFields
      .map(f => `(?:${FIELD_SYNONYMS[f].join('|').replace(/\s+/g, '\\s*')})`)
      .join('|');

    // Updated Regex to capture multiple values
    regexCache[fieldName] = new RegExp(
      `(?:${synonyms.join('|').replace(/\s+/g, '\\s*')})\\s*[:\\-]*\\s*([\\s\\S]*?)(?=\\s*(?:${boundaryPattern}|$))`,
      'gi' // 'i' -> case insensitive, 'g' -> global search for multiple occurrences
    );
  }

  console.log(`Regex for ${fieldName}:`, regexCache[fieldName]);
  return regexCache[fieldName];
}

// Function to extract multiple values for a field
function extractField(text, fieldName, allFields) {
  const regex = createFieldRegex(fieldName, allFields);
  const matches = [...text.matchAll(regex)]; // Extract all occurrences

  if (matches.length > 0) {
    const extractedValues = matches.map(match => match[1].trim()).filter(Boolean); // Remove empty matches
    const updatedText = matches.reduce((txt, match) => txt.replace(match[0], '').trim(), text); // Remove matched text

    console.log(`Field ${fieldName} matched with values:`, extractedValues);
    console.log('Remaining text after extraction:', updatedText);

    return { value: extractedValues.join(', '), updatedText }; // Store all values in a single string
  }

  console.log(`Field ${fieldName} not found.`);
  return { value: "", updatedText: text };
}

// Recursive Parsing Logic to process fields
function parseOrderDataRecursive(text, fieldNames, result = {}) {
  if (!text.trim() || fieldNames.length === 0) return result;

  console.log('Current text:', text);
  console.log('Remaining fields:', fieldNames);

  const [currentField, ...remainingFields] = fieldNames;

  const { value, updatedText } = extractField(text, currentField, fieldNames);

  if (value) {
    result[currentField] = value;
  }

  return parseOrderDataRecursive(updatedText, remainingFields, result);
}

// Main Parsing Function
function parseOrderData(text) {
  const fieldNames = Object.keys(FIELD_SYNONYMS);
  return parseOrderDataRecursive(text, fieldNames);
};

// Test Input (Multiple Values for Same Field)
const testText = `
order:
Name: your name 
Address: 123 st nagar indore 
Pincode: 452010
District: indore 
State: Madhya Pradesh
Phone: 9876543210
Order: 2 Pizza
`; 

// Parse the text
console.log('Starting parsing process...');
const parsedData = parseOrderData(testText);
console.log('Parsed data:', parsedData);
